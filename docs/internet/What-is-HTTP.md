---
layout: default
title: What is HTTP?
parent: Internet
nav_order: 2
---

## What is HTTP?

[An overview of HTTP - HTTP | MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)

[HTTP Crash Course & Exploration](https://www.youtube.com/watch?v=iYM2zFP3Zn0)

[Everything you need to know about HTTP](https://cs.fyi/guide/http-in-depth)

[HTTP/1 to HTTP/2 to HTTP/3](https://www.youtube.com/watch?v=a-sBfyiXysI)

### HTTP란?

HTTP는 애플리케이션 계층의 프로토콜이며 통신을 위해서 전송 프로토콜을 필요로한다. HTTP는 신뢰 가능한 전송 프로토콜이라면 무엇이든 사용할 수 있으나, 일반적으로는 TCP 또는 암호화된 TCP 연결인 TLS에 의존한다.

HTTP는 HTML 문서와 같은 리소스를 어떻게 요청하고 응답할지를 규정한 클라이언트-서버 프로토콜이다. 보통 웹 브라우저인 클라이언트에 의해 전송되는 메시지를 요청이라 부르며, 서버에서 요청에 대한 반응으로 전송되는 메시지를 응답이라고 한다. HTTP는 초기에는 HTML만 가져올 수 있도록 설계되었지만 확장성을 갖추게 되면서 이미지나 비디오, 폼과 같은 여러 타입의 데이터를 교환할 수 있게 되었다. 완전한 웹 페이지는 여러개의 요청-응답 프로세스를 통해 전달받은 하위 문서(텍스트, 레이아웃, 이미지, 비디오, 스크립트 등)들로 이루어진다. 

### HTTP의 주요 구성원들

HTTP는 클라이언트-서버 프로토콜이며 클라이언트로부터 전송되는 요청을 서버가 응답하는 단순한 과정으로 요약될 수 있다. 요청을 하는 개체를 클라이언트라고도 부르지만 사용자 에이전트라고도 한다. 일반적으로는 웹 브라우저가 주로 요청을 하지만, 웹 브라우저 말고도 요청을 하는 개체 모두를 클라이언트나 사용자 에이전트라고 정의한다는 사실을 유의해야 한다. 각각의 요청들은 서버로 전송되고, 서버는 요청을 처리하여 클라이언트에 응답을 전송한다. 앞선 클라이언트의 정의와 유사하게 서버 역시 응답을 하는 모든 개체를 서버라고 부른다. 추가로 클라이언트와 서버 사이에는 캐싱과 같은 다양한 작업을 수행하는 프록시(Proxy)들도 존재한다.

<img width="482" alt="스크린샷 2023-03-26 오후 2 34 52" src="https://user-images.githubusercontent.com/123535862/227863917-9f619014-da7f-4c59-8855-cdb3c287f8bf.png">

**클라이언트(사용자 에이전트)**

앞서 언급했듯이 클라이언트(사용자 에이전트)는 HTTP 요청을 하는 모든 사용자 개체를 의미한다. 대부분의 요청은 웹 브라우저에 의해 이루어지고 웹 브라우저는 절대로 서버 역할을 담당할 수 없지만 애플리케이션의 서버 단에서도 충분히 HTTP 요청이 일어날 수 있으며 어찌되었든 요청을 하는 모든 개체는 굳이 웹 브라우저가 아니더라도 클라이언트라고 보는 것이 정확하다.

웹 페이지를 로드하기 위해서는 웹 브라우저가 웹 페이지에 필요한 HTML 문서를 먼저 서버에 요청을 해야한다. HTML 문서의 응답이 완료되면 웹 브라우저는 문서를 해석하여 스크립트나 CSS, 이미지와 같은 필요한 리소스들을 추가적으로 요청을 한다. 그리고 이 모든 리소스들을 결합하여 완전한 웹 페이지를 로드한다. 이후, 브라우저에 의해 실행되는 웹 페이지의 스크립트들은 추가적인 리소스를 요청할 수도 있으며 브라우저는 이러한 스크립트에 따라 동적으로 웹 페이지를 업데이트한다.

**서버**

서버는 클라이언트의 요청에 따라 리소스들을 응답한다. 서버는 클라이언트처럼 단일한 웹 브라우저로 이루어져 있지 않다. 서버는 로드 밸런싱을 통해 여러개의 서버의 집합으로 이루어져 있을 수도 있고 많은 타 서버, 혹은 프로그램들과의 상호작용이 있을 수 있다. 

**프록시**

클라이언트와 서버의 통신 사이에는 HTTP 메시지가 거쳐가는 다양한 중재자들이 존재한다. 네트워크의 계층적인 구조 덕분에 대부분의 중재자들은 전송, 네트워크, 하드웨어 계층에서 동작하며 성능에 큰 영향을 주지만 HTTP와 같은 애플리케이션 계층에서는 이들이 어떻게 동작하는지 눈에 보이지 않는다. 하지만 이들 중에서도 애플리케이션 계층에서 동작하는 중재자들이 존재하는데 이를 프록시라고 부른다. 프록시는 눈에 보이거나 보이지 않을 수 있으며 캐싱, 필터링, 로드 밸런싱, 인증, 로깅과 같은 다양한 기능을 수행할 수 있다.

### HTTP 메시지

HTTP 메시지는 HTTP/1.1 까지는 human-readable했다. 하지만 HTTP/2에 이르러서는 이진 구조인 프레임으로 내장되었으며 멀티플렉싱과 헤더 압축과 같은 최적화가 가능해졌다. 하지만 형태와 최적화의 정도만 달라졌을 뿐 HTTP 메시지의 기본적인 구조는 HTTP/1.1과 크게 다르지 않다. 

**HTTP Request message**

HTTP 메시지는 요청과 응답 메시지로 구분지어볼 수 있다. 우선, HTTP 요청 메시지는 다음과 같다.

<img width="481" alt="스크린샷 2023-03-27 오후 2 34 19" src="https://user-images.githubusercontent.com/123535862/227863987-b8d29b18-2fc5-45d8-98f3-9d137e543ccc.png">


**HTTP 메서드**: HTTP 메서드는 클라이언트가 수행하는 동작을 정의한다. 현재 매우 다양한 HTTP 메서드가 존재하지만 가장 대표적인 메서드로는 GET, POST, PUT, DELETE가 있다.

| GET | 서버로부터 데이터를 취득하고자 할 때 사용된다. |
| --- | --- |
| POST | 서버에 데이터를 전송하고자 할 때 사용된다. |
| PUT | 서버에 저장되어 있는 데이터를 업데이트하고자 할 때 사용된다. |
| DELETE | 서버에 저장되어 있는 데이터를 삭제하고자 할 때 사용된다. |

**리소스의 경로**: 리소스의 URL은 문맥상 명백한 요소들은 제거한 채 명시된다. 즉, 프로토콜, 도메인, TCP 포트와 같은 것들이 리소스의 URL에서 제거된다.

**HTTP 버전:** 현재 사용되고 있는 HTTP의 버전이 명시된다.

**HTTP 헤더:** 추가적인 옵션을 전송할때 사용된다.

**HTTP 바디**: POST와 같은 폼 양식을 제출할 때의 내용이 기입된다.

**HTTP Response Message**

HTTP 응답 메시지는 다음과 같은 요소들로 이루어져 있다.

<img width="482" alt="스크린샷 2023-03-27 오후 2 34 33" src="https://user-images.githubusercontent.com/123535862/227864040-31a885cd-bdf4-4bdd-8ebd-69b0af073ace.png">

**HTTP 버전:** 현재 사용되고 있는 HTTP의 버전이 명시된다.

**HTTP 상태 코드**: 요청에 대한 응답의 성격을 정의한 코드이다. 다음과 같이 앞자리에 따라 응답의 성격을 대략적으로 파악할 수 있다.

| 1xx  | Informational - 요청이 수신되었고 프로세스가 진행중이다 |
| --- | --- |
| 2xx | Success - 요청과 응답이 성공했다 |
| 3xx | Redirection - 추가적인 동작이 필요하다 |
| 4xx | Client Error - 요청에 문제가 있다 |
| 5xx | Server Error - 요청에는 문제가 없지만 서버 내부의 문제로 인해 응답할 수가 없다 |

**HTTP 상태 메시지**: 상태 코드에 대한 신뢰할 수 없는 짧은 설명이 명시된다.

**HTTP 헤더**

**HTTP 바디**: 주로 리소스들이 담긴다.

### HTTP 통신의 흐름

클라이언트가 서버나 프록시와 통신을 하고자 할 때는 다음과 같은 단계를 거친다.

1. **TCP 커넥션을 활성화한다**: TCP 커넥션은 요청을 전송하거나 응답을 수신하는 등의 역할을 수행한다. 클라이언트는 새로운 TCP 커넥션을 활성화할 수도 있고, 기존의 TCP 커넥션을 활용할 수도 있고, 어떤 경우에는 여러개의 TCP 커넥션을 동시에 활성화할 수도 있다.
2. **HTTP 메시지를 전송한다**: HTTP/2 이전의 HTTP 메시지는 human-readable했다. HTTP/2에 이르러 HTTP 메시지는 프레임들로 캡슐화되었고 인식하기 어려워졌지만 기본 원칙은 동일하다.
    
    ```
    GET / HTTP/1.1
    Host: developer.mozilla.org
    Accept-Language: fr
    ```
    
3. **서버로부터 응답 받은 HTTP 메시지를 해석한다**
    
    ```
    HTTP/1.1 200 OK
    Date: Sat, 09 Oct 2010 14:28:02 GMT
    Server: Apache
    Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
    ETag: "51142bc1-7449-479b075b2891b"
    Accept-Ranges: bytes
    Content-Length: 29769
    Content-Type: text/html
    
    <!DOCTYPE html>… (here come the 29769 bytes of the requested web page)
    ```
    
4. **TCP 커넥션을 종료하거나 다음 요청을 위해 재사용한다**

HTTP 파이프라이닝이 활성화되면, 응답이 완료되기를 기다리지 않고도 여러개의 요청을 전송할 수 있다. HTTP 파이프라이닝은 HTTP/1.1 시절의 네트워크의 기술로는 활용하기 매우 어려웠기에 HTTP/2부터는 프레임을 활용한 멀티플렉싱 요청 기능으로 대체되었다.

### HTTP의 주요 특징들

HTTP가 가지는 기본적인 특징들은 다음과 같다.

**HTTP is simple**: ****

HTTP/2에서 HTTP 메시지를 frames로 캡슐화함으로써 약간의 복잡도가 추가되었더라도 HTTP는 기본적으로 human-readable하며 간단하게 설계되었다. 때문에 HTTP 메시지는 개발자가 테스팅하기에도 용이하며 입문자가 접근하기에도 용이하다.

**HTTP is extensible**: 

HTTP/1.0에서 HTTP 헤더가 도입되면서 HTTP는 확장 가능한 프로토콜이 되었고 여러가지 실험들이 가능하게 되었다. HTTP는 헤더의 구문에 대한 클라이언트와 서버 간의 합의만 이루어진다면 간단하게 새로운 기능을 도입하는 것이 가능하다.

**HTTP is stateless, but not sessionless:**

HTTP는 하나의 커넥션에서 연속적으로 수행되는 두 개 이상의 HTTP 요청은 서로 독립적이기 때문에 기본적으로는 stateless한 프로토콜이다. 이러한 부분은 사용자가 애플리케이션을 통해 장바구니와 같은 동일한 사용자 경험을 누리고자 할 때 문제가 될 수 있다. 이 문제는 HTTP 쿠키를 통해 stateful한 세션을 구축함으로써 해결될 수 있다. 웹 사이트는 HTTP 쿠키를 사용하여 각각의 HTTP 요청에 동일한 컨텍스트, 상태를 공유하는 세션을 구축할 수 있고 이를 통해 stateful한 사용자 경험을 제공할 수 있다.

**HTTP and connections:**

사실 커넥션은 전송 계층에서 컨트롤되며, 때문에 본질적으로는 HTTP의 통제 밖에 위치한다. 따라서 HTTP는 커넥션을 생성하기 위해 기본 전송 프로토콜에 의존해야 하기는 하지만, 커넥션을 생성할 수 있다고 어떠한 전송 프로토콜이든지 의존할 수 있는 것은 아니다. HTTP가 의존할 수 있는 전송 프로토콜은 신뢰 가능하며 안정적(최소한 에러 체킹 정도는 지원하는)이어야 한다. 인터넷에 존재하는 일반적인 전송 프로토콜은 TCP와 UDP인데 UDP는 신뢰 가능하지 않기 때문에 HTTP는 TCP 표준에 의존한다.

클라이언트와 서버와 HTTP 요청과 응답을 주고받기 전에 반드시 TCP 연결이 생성되어야 한다. 가장 기본적인 동작은 HTTP/1.0 에서 시작된, 각각의 요청마다 새로운 TCP 연결을 생성하는 방식이다. 하지만 이는 하나의 TCP 커넥션을 공유하며 다수의 요청을 전송할 수 있는 경우보다 비효율적이다.

이러한 문제점을 극복하기 위해 HTTP/1.1에 들어서는 파이프라이닝(pipelining)과 지속적인 연결(persistent connections)이 도입되었다. 이때부터는 `Connection` 헤더를 사용하여 TCP 커넥션을 제어할 수 있었고 이를 통해 하나의 커넥션을 공유하는 다수의 메시지 전송이 가능해졌다.

추가로 현재는 HTTP가 의존할 전송 프로토콜과 관련된 다양한 실험들이 전개되고 있다. 2022년 소개된 HTTP/3는 UDP 전송 프로토콜을 기반으로 하는 QUIC에 의존하고 있다. 

### HTTP 주요 기능들

HTTP가 가지고 있는 확장성 덕분에 시간이 지남에 따라 HTTP는 웹의 더 많은 것들을 제어할 수 있게 되었고 많은 기능들이 추가되었다. 예시로 캐싱과 인증은 HTTP 역사 초기부터 가능했었으며, 반면에 `origin` 제약사항을 완화시키는 조치는 2010년, 비교적 최근에 추가되었다.

다음은 HTTP가 제공하는 일반적인 기능의 목록이다.

| 캐싱 | 서버는 프록시와 서버에 무엇을 캐시하고 얼마나 이를 캐시할지를 지시할 수 있다. 클라이언트는 캐시된 문서를 무시하도록 프록시에 지시할 수 있다. |
| --- | --- |
| origin 제약 사항 | 스누핑(snooping)과 개인 정보 침해를 예방하기 위해 기본적으로 웹 브라우저는 웹 페이지들을 명백하게 구분한다. 오직 같은 origin을 가진 페이지만이 웹 페이지의 정보에 접근할 수 있는 것이다. 하지만 이러한 강력한 제약 사항은 서버에 부담이 가게 하기 때문에 2010년, HTTP는 이를 완화할 수 있는 기능을 추가했다. HTML 문서가 서버 단에서 HTTP 헤더에 명시한 도메인을 가진 웹 페이지의 리소스를 patch할 수 있도록 한 것이다. |
| 인증 | 어떤 페이지들은 특정 사용자만이 접근할 수 있도록 보호된다. HTTP는 WWW-Authenticate 헤더나 쿠키를 사용하는 방식으로 인증 기능을 제공한다. |
| 프록시와 터널링 | 서버와 클라이언트는 종종 인터넷과 같은 공유 네트워크를 통해 통신하는 것이 아닌, 인트라넷과 같은 사적 네트워크(터널링)를 통해 통신하기도 한다. 이 경우 HTTP 요청은 프록시를 통해 은밀하게 전송된다. 물론 이러한 기능을 제공하는 모든 프록시가 HTTP 프록시는 아니지만, 대표적으로 FTP와 같은 프로토콜들을 HTTP 프록시를 통해 처리될 수 있다. |
| 세션 | HTTP 쿠키는 stateful한 통신을 가능하게 한다. HTTP의 stateless한 특징에도 불구하고 이를 통해 세션을 구축할 수 있다. 이는 광범히 적용될 수 있는 유용한 기능이다. |

### HTTP/0.9 (1991)

1991년, 처음 문서화된 HTTP의 버전은 HTTP/0.9였다. 당시에는 매우 단순하게 GET 메서드만이 존재하였다. 당시에는 Client가 웹 페이지에 접속하기 위해 다음과 같은 요청만 하면 되었다.

```
GET /index.html
```

그리고 Server의 응답은 다음과 같았다.

```
--------------
response body
--------------

(connection closed)
```

즉, 서버가 요청을 받으면 응답으로 HTML 파일을 보내고 바로 연결이 닫히는 구조였다. 당시의 HTTP는 1) 헤더가 없었으며 2) GET 메서드 만이 존재했고 3) 응답 컨텐츠는 반드시 HTML이어야 했다.

### HTTP/1.0 (1996)

1996년, 기존 버전보다 크게 기능이 향상된 HTTP/1.0이 등장하였다. HTTP/1.0은 HTTP/0.9와 다르게 1) HTML 외에 이미지나 비디오 파일과 같은 다양한 컨텐츠를 응답할 수 있었고, 2) POST와 HEAD와 같은 메서드가 추가되었다. 뿐만 아니라 3) 응답과 요청 시 데이터에 HTTP 헤더가 추가되었으며 헤더에는 상태 코드나 charset, multi-part type, 권한, 캐싱, 인코딩 등의 관련된 정보가 명시되었다. 

HTTP/1.0의 요청에서는 HTTP/0.9에서는 헤더가 없어 불가능했던 Host, User-Agent, 컨텐츠 타입 등과 같은 정보들을 다음과 같이 클라이언트가 동봉할 수 있었다.

```
GET / HTTP/1.0
Host: cs.fyi
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*
```

HTTP/1.0의 응답에서는 다음과 같이 상태 코드와 콘텐츠 정보에 대한 정보를 서버가 동봉할 수 있었다.

```
HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

--------------
response body
--------------

(connection closed)
```

HTTP/1.0의 응답과 요청 헤더는 여전히 ASCII 인코딩을 유지하고 있었지만 응답 바디만큼은 이미지나 비디오, HTML과 같은 여러 컨텐츠 타입을 가질 수 있었다. 때문에 이때부터는 서버가 클라이언트로 여러 컨텐츠 타입들을 전송할 수 있었고 HTTP의 ‘Hyper Text’(HTML)는 그 의미가 무색해지게 되었다.

하지만, HTTP/1.0의 단점은 한번의 연결에 여러 요청을 할 수 없었다는 점이었다. 즉, 클라이언트가 서버로 컨텐츠를 요청할 때마다 새로운 TCP 연결을 생성해야했고 응답이 완료될 시 TCP 연결은 끊어졌다. 만약 당신이 방문하는 웹페이지가 10개의 이미지, 5개의 스타일시트, 5개의 자바스크립트 파일로 이루어져있다면 총 20번의 TCP 연결이 생성되고 종료되어야 온전한 웹페이지를 응답받을 수 있었다는 뜻이다. 이렇게 많은 수의 커넥션은 심각한 성능 저하를 초래한다. 거기다가 3-way Handshake 방식의 커넥션 생성 방법은 이를 더욱 심화시켰다.

### Three-way Handshake

Three-way Handshake는 서버와 클라이언트가 컨텐츠를 주고 받기 전에 3번, 일정량의 패킷을 서로 주고 받음으로써 TCP 연결을 시작하는 방식이다. 서버와 클라이언트가 주고받는 내용은 다음과 같다.

| SYN | 클라이언트가 SYN 패킷 X를 생성하여 서버로 전송한다. 이때 X는 무작위의 숫자이다. |
| --- | --- |
| SYN ACK | 서버가 클라이언트가 보낸 SYN 패킷 X에 1을 더하고 ACK 패킷 Y를 생성하여 클라이언트로 다시 전송하여 요청을 확인한다. 이때 Y 역시 무작위의 숫자이다. |
| ACK | 클라이언트는 서버가 생성한 ACK 패킷 Y에 1을 더하여 다시 서버로 전송한다. |

<img width="720" alt="스크린샷 2023-03-21 오후 3 25 40" src="https://user-images.githubusercontent.com/123535862/227864121-d514646d-ca49-42c9-866d-f48d4c9822ba.png">


이러한 Three-way Handshake 방식을 `Connection: keep-alive`라는 헤더를 추가하는 방식으로 극복하려는 시도들이 존재했다. 해당 헤더는 컨텐츠(Application Data)를 요구할 때마다 불필요하게 반복되는 Tree-way Handshake를 진행하지 않게 하기 위해 커넥션을 끊지 않도록 요구하는 옵션이다. 하지만, 당시에는 널리 사용되지 않았고 Three-way Handshake로 인한 문제는 여전했다.

이러한 **connectionless**와는 별개로, HTTP는 **stateless** 프로토콜이기도 하다. 서버는 클라이언트의 정보를 유지하지 않으며, 때문에 클라이언트는 서버에 요청을 할 때 매번 같은 내용을 전송해야 했다. 이는 성능 저하에 더욱 더 큰 불을 지른다. 즉, 클라이언트가 열어야 하는 많은 수의 연결 외에도 유선에서 일부 중복 데이터를 전송해야 하므로 대역폭 사용량이 증가하게 되는 것이다.

### HTTP/1.1 (1999)

1999년, HTTP/1.1이 출시되었다. HTTP/1.1에서는 1) PUT, PATCH, OPTIONS, DELETE와 같은 메서드들이 추가되었으며 2) Host 헤더가 선택이 아닌 필수가 되었다. 제일 중요한 특징은 앞서 언급했던 connectionless에서 비롯된 문제들이 보완되었다는 것이다. HTTP/1.1에서는 3) 지속적인 연결을 도입하여 연결은 기본적으로 닫히지 않고 여러 개의 순차적 요청을 허용하는 열린 상태로 유지되었다. 추가로 4) 서버의 응답이 완료되지 않아도 여러 요청을 전송할 수 있는 Pipelining 기능을 도입하여  HOL (Head Of Line) Blocking과 같은 문제를 해결하려고 하였으나 당시 많은 proxy server들이 이를 잘 다루지 못하였고 결국 많은 브라우저에서 해당 기능은 삭제되었다.

지속적인 연결과 Pipelining을 통해 이득을 보기 위해서는 응답 시, Content-Length 헤더가  반드시 가능한 상태라고 명시되어 있어야만 한다. 그래야만 전송이 완료되었을 때, 클라이언트에 이를 알리고 다음 요청을 전송할 수 있게 되며 다음 응답을 기다리기 시작할 수 있기 때문이다. 하지만, 만약 서버가 보내는 데이터가 동적이어서 해당 데이터의 Content-Length를 특정할 수 없는 상황인 경우, 서버는 chunked encoding 기법을 사용하여 Content-Length를 생략할 수 있다. 

Chunked Transfers는 서버가 Content-Length를 특정할 수 없는 경우(데이터가 동적으로 변화하는 경우) 사용되는 기법으로써 컨텐츠를 조각조각 쪼개고 각각의 컨텐츠 조각에 Content-Length를 더해 이를 전송하는 기법이다. 전송이 완료되면, 서버는 이를 클라이언트에 알리기 위해 비어있는 조각을 전송하는데 (이 경우 Content-Length는 0의 값을 가진다) 이를 통해 클라이언트는 전송이 완료되었음을 알게 된다. 서버가 Chunked Transfers를 통해 컨텐츠를 전송한다는 사실은 응답 헤더에 `Transfer-Encoding: chunked`을 명시함으로써 클라이언트에 알리는 것이 가능하다.

앞서 설명한 특징 외 HTTP/1.1은 HTTP/1.0과 비교했을 때 캐싱, Byte Ranges, Charset, 쿠키, 새로운 상태코드 등, 더 다양한 기능들을 가지고 있었다. 이에 대한 더욱 상세한 내용은 다음 링크를 참고하라

[](https://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf)

HTTP/1.1은 1999년에 도입된 이래로 많은 시간동안 표준이 되어왔지만, 오늘날의 웹페이지를 로드하는 것은 많은 리소스를 로드해야한다. 아무리 간단한 페이지라도 30개 이상의 커넥션이 필요하다. 앞서 설명했던 지속적인 연결이나 파이프라이닝의 경우에도 웹이 발달하면서 점점 더 그 한계와 단점들이 드러나기 시작했는데 이를 극복하기 위해 수많은 개발 방법론들이 등장하기 시작했다.

### SPDY (2009)

Google은 2009년, 보안성과 성능이 향상된 SPDY라 불리는 새로운 프로토콜을 발표한다. 네트워크 성능 향상을 위해 대역폭(Bandwidth)을 늘리는 것은 처음에는 어느 정도의 성능 향상을 가져오지만 일정 포인트를 지나면 이로 인한 성능 향상이 드라마틱하게 진행되지는 않는다. 하지만 대역폭을 늘리는 것과는 다르게 지연시간(Latency)을 줄이는 작업의 경우는 성능 향상이 일정하게 이루어지는데 구글의 SPDY는 바로 이 점에 착안해 네트워크 성능 향상을 위해 지연 시간을 줄이는데 집중한다.

<aside>
💡 Latency VS Bandwidth
Latency는 데이터가 출발지점으로부터 목적지까지 도착하는 시간을 의미하고 Bandwidth는 1초마다 전송할 수 있는 데이터의 양을 의미한다.

</aside>

SPDY는 multiplexing, conpression, prioritization, security와 같은 특징들을 가지고 있었으며 이는 나중에 다루게 될 HTTP/2가 크게 영감을 받았다. 또한, SPDY는 HTTP를 완전히 대체하지 않는다. SPDY는 HTTP 위에서 동작하는 translation layer이며 HTTP가 보내는 요청을 변형하는 방식으로 동작한다. 2015년, 구글은 SPDY를 HTTP/2에 통합하는 것을 결정하며 해당 프로토콜의 막을 내린다.

### HTTP/2 (2015)

앞서 설명했듯이 HTTP/2는 Latency를 줄이는 방식으로 네트워크의 성능 향상을 도모하는 SPDY의 기본적인 골자를 따라간다. HTTP/1.1과 비교했을 때, HTTP/2가 가지는 특징들은 다음과 같다.

**Binary Protocol**

HTTP/2는 지연 시간을 줄이기 위해 기존에는 textual하게 진행되던 프로토콜을 binary 프로토콜로 전환했다. 프로토콜이 binary로 전환되면서 사람이 이를 파악하기는 더 어려워졌지만 컴퓨터의 입장에서 이를 분석하기는 더 쉬워졌기 때문에 지연 시간을 줄일 수 있었던 것이다. 

HTTP/2의 주요한 빌딩 블록 중 하나는 Frames이다. HTTP 메시지는 하나 이상의 Frames로 구성되어 있다. 메타 데이터를 위한 HEADER Frames와 동봉된 데이터를 위한 DATA Frames가 가장 대표적이며 이외 RST_STREAM, SETTINGS, PRIORITY Frames도 존재한다.

<img width="561" alt="스크린샷 2023-03-22 오전 11 25 25" src="https://user-images.githubusercontent.com/123535862/227864320-5da31b1b-d4f4-4f0d-90a5-f4bf879aafb7.png">

HTTP/2를 이루는 또 다른 빌딩 블록 중 하나는 Stream이다. HTTP/2의 모든 요청과 응답에는 고유한 Stream ID가 있으며 앞서 말했듯 이는 여러 Frames들로 이루어져 있다. Frames는 binary 데이터의 조각이며, Stream은 이러한 Frames들의 집합이다. 각각의 Frames는 헤더를 가지고 있으며 헤더에는 고유한 Stream ID가 포함된다. 어찌되었건 HTTP/2의 모든 요청과 응답에는 Stream ID가 부여된다. 결론적으로 각 stream에 고유한 식별 번호가 부여되고 이를 통해 각 stream들을 조합 할 수 있었기 때문에 HTTP/1.1에서는 미완의 과제에 그쳤던 Pipelining을 완전하게 구현할 수 있었다.

추가로 RST_STREAM Frames에 대해서도 언급할만한 가치가 있는 것 같다. RST_STREAM Frame은 특정 Stream을 금지할 때 사용되는 Frame이다. HTTP/1.1에서는 서버가 클라이언트에 특정 데이터를 응답하지 않도록 하는 방법은 오로지 연결을 끊는 것 뿐이었다. 하지만 이는 다른 리소스를 요청할 때는 새로운 연결을 다시 열어야했기 때문에 지연 시간을 증가시켜 네트워크 성능을 저하시킨다. 하지만 HTTP/2에서는 RST_STREAM을 통해 특정 Stream만 응답하지 않도록 하는 것이 가능해졌고 이에 따라 연결을 끊고 다시 생성할 필요가 없어졌다.

**Multiplexing**

HTTP/2는 앞서 언급한대로 binary 프로토콜이며 요청과 응답에 frames와 stream을 사용한다. 덕분에 한번 TCP 연결이 생성되면 해당 연결 내에서 모든 stream들이 비동기적으로 전송될 수 있다. 이는 특정 패킷이 고유한 stream ID를 가지고 있고, 이를 통해 패킷이 속한 스트림을 식별할 수 있기 때문에 데이터가 꼬이는 걱정을 하지 않아도 되기 때문이다. 이러한 비동기적인 특징은 HTTP/1.1 Pipelining 기능에서 발생했던 HOL(Head OF Line) Blocking과 같은 문제들을 해결하는데 도움이 되었다.

**Header Compression**

HTTP는 기본적으로 stateless하기 때문에 하나의 클라이언트가 지속적으로 어떤 서버에 계속해서 접속한다면 stateful하기 위해 보내야 하는 헤더의 양이 많아질 수 밖에 없다. 이러한 헤더의 용량 증가는 대역폭의 사용량을 늘리며 지연 시간을 증가시키 때문에 네트워크 성능에 영향을 끼칠 수 밖에 없다. 

이를 극복하기 위해 HTTP/2는 header compression을 도입했다. 요청과 응답 본문과는 다르게 헤더는 gzip과 같은 압축 메커니즘을 사용하지 않는다. 대신에 헤더는 Huffman 코드를 사용하여 인코딩되며, 서버와 클라이언트 모두에서 유지 관리되는 압축 테이블을 통해 중복되는 헤더들을 생략하고 효율적인 헤더 전송을 도모하는 압축 메커니즘을 사용한다.

**Server Push**

Server push는 클라이언트가 특정 컨텐트를 요청하기 전에도 미리 클라이언트에 컨텐츠를 전송할 수 있도록 하는 기능이다. 클라이언트가 어떤 전체 웹페이지를 로드하고자 한다면 이에 필요한 자원들을 분석하여 서버에 순차적으로 요청해야 한다. 하지만 server push 기능을 사용하면 클라이언트가 요청할만한 컨텐츠들을 미리 전송할 수 있다. 이는 불필요한 요청-응답 과정을 줄이는데에 도움이 된다. 그리고 이렇게 미리 보내는 특별한 frame을 PUSH_PROMISE frame이라고 한다.

**Request Prioritization**

클라이언트는 자신이 응답받게 될 frame들의 우선 순위를 설정하는 PRIORITY frame을 서버에 전송할 수 있다. 이러한 우선 순위와 관련된 정보를 클라이언트가 전송하지 않는다면 기본적으로 서버는 파이프라이닝을 통해 비동기적으로 응답한다.

**Security**

과거, TLS 통신의 보안과 관련되어 HTTP/2의 새로운 대채자가 필요한지 아닌지에 대한 논의가 활발했던 적이 있다. 해당 논의의 결론은 새로운 대체자가 필요하지 않다는 것이었고, 결과적으로 HTTP/2는 TLS통신의 표준이 되었다. HTTP/2가 암호화를 반드시 요구하지 않는다는 사실은 분명 문제였지만 암묵적 표준이됨으로써 묵과되었다. 어찌되었건, TLS에서 동작하기 위해서는 몇 가지 요구조건이 붙었다. TLS 1.2 이상의 버전을 요구하는 것이 대표적인 요구사항이었다.

### HTTP/3 (2022)

HTTP/3는 QUIC를 기초로 하는 프로토콜이다. QUIC는 UDP를 베이스로 하여 TCP를 대체하기 위해 만들어진 Tansport Layer Protocol이다. QUIC는 멀티플렉싱, 보안, stream based하도록 디자인 되었으며 TCP와 HTTP/2를 대체한다.

**Multiplexing**

QUIC 역시 HTTP/2처럼 한번의 커넥션에 여러 스트림을 전송할 수 있다. 하지만, QUIC는 HTTP 에만 국한되지 않고 여러 애플리케이션에 사용될 수 있다

**Stream based**

HTTP/2 와 동일한 stream 기반의 프로토콜이다.

**Unreliable Datagram**

QUIC는 데이터를 전송할 때, unreliable datagram을 사용한다. 이것은 QUIC가 목적지에 정확히 도착했는지 아닌지는 보장하지않는다는 것을 의비한다. QUIC가 보장하는 것은 데이터의 순서 뿐이다. 이러한 QUIC의 특징은 UDP와 매우 유사하다.

**Connection Migration**

QUIC는 connection migration을 지원한다. connection migration은 커넥션이 하나의 IP주소에서 다른 IP 주소로 넘어갈 수 있다는 것을 의미한다. 이는 TCP 커넥션이 가지는 기능과 유사하다.

**Loss Recovery & Congestion Control**

QUIC는 패킷 유실에 대한 손실 복구(Loss Recovery)를 지원한다. QUIC는 패킷 손실을 복구하기 위해 TCP와 유사하게 혼잡 제어(congestion control)와 손실 복구를 동시에 사용한다.

**Handshake**

QUIC는 클라이언트와 서버 간의 안전한 커넥션을 생성하기 위해 Handshake를 사용한다. QUIC는 이를 위해 TLS 1.3 버전을 사용한다. 참고로 HTTP/2의 경우 TLS 1.2 버전을 사용했다.

**Header Compression**

QUIC는 HTTP/2와 동일하게 Header Compression을 위해 HPACK을 사용한다.

**Security**

QUIC는 보안을 위해 TLS 1.3 버전을 사용한다.
